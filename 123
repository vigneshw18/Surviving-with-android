
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.documentum.fc.client.DfClient;
import com.documentum.fc.client.DfQuery;
import com.documentum.fc.client.DfSingleDocbaseModule;
import com.documentum.fc.client.IDfClient;
import com.documentum.fc.client.IDfCollection;
import com.documentum.fc.client.IDfFolder;
import com.documentum.fc.client.IDfQuery;
import com.documentum.fc.client.IDfSession;
import com.documentum.fc.client.IDfSessionManager;
import com.documentum.fc.common.DfException;
import com.documentum.fc.common.DfLoginInfo;
import com.documentum.fc.common.IDfLoginInfo;
import com.documentum.fc.impl.util.RegistryPasswordUtils;

public class NawahImportValidationForUPICRevision extends DfSingleDocbaseModule {

    public String validateDocNoRevision(String documentNumber) {
        String newRevision = "00"; // Default revision if no document is found
        IDfSession session = null;
        try {
            session = getAdminSession();
           
            String currentRevision = getLatestRevision(session, documentNumber);
            System.out.println("currentRevision : "+currentRevision);
            if (currentRevision != null) {
                newRevision = incrementRevision(currentRevision);
                System.out.println("newRevision :: "+newRevision);
            }
        } catch (DfException e) {
            e.printStackTrace();
        } finally {
            if (session != null) {
                session.getSessionManager().release(session);
            }
        }
        System.out.println("newRevision ::: "+newRevision);
        return newRevision; // return incremented revision or "00" if no revision is found
    }

    private String getLatestRevision(IDfSession session, String documentNumber) throws DfException {
        IDfQuery query = new DfQuery();
        // Query to select all revisions for the given document number
        String dql = "SELECT revision FROM enec_nawah WHERE document_number = '" + documentNumber + "' AND document_number != 'untitled'";
        System.out.println("dql :: "+dql);
        query.setDQL(dql);
        IDfCollection collection = null;
        List<String> revisions = new ArrayList<>();
        try {
            collection = query.execute(session, IDfQuery.DF_READ_QUERY);
            while (collection.next()) {
                revisions.add(collection.getString("revision"));
                System.out.println("Inside collection : "+revisions);
            }
        } finally {
            if (collection != null) {
                collection.close();
            }
        }

        // Sort the revisions
        Collections.sort(revisions, new Comparator<String>() {
            public int compare(String rev1, String rev2) {
                return compareRevisions(rev1, rev2);
            }
        });
      
        return revisions.isEmpty() ? null : revisions.get(revisions.size() - 1);
    }
    
    private int compareRevisions(String rev1, String rev2) {
    	System.out.println("Inside compareRevisions");
        // Regular expression to split the revision into numeric and alphabetic parts
        Pattern pattern = Pattern.compile("(\\d+)([A-Za-z]?)");
        System.out.println("pattern : "+pattern);
        Matcher m1 = pattern.matcher(rev1);
        Matcher m2 = pattern.matcher(rev2);
        System.out.println("m1 : "+m1);
        System.out.println("m2 : "+m2);

        if (m1.matches() && m2.matches()) {
            // Compare the numeric parts
            int numPartComparison = Integer.compare(Integer.parseInt(m1.group(1)), Integer.parseInt(m2.group(1)));
            if (numPartComparison != 0) {
                return numPartComparison;
            }
            // Compare the alphabetic parts
            return m1.group(2).compareTo(m2.group(2));
        }
        // Fallback comparison if pattern does not match
        System.out.println("rev1.compareTo(rev2) "+rev1.compareTo(rev2));
        return rev1.compareTo(rev2);
    }

    private String incrementRevision(String revision) {
    	System.out.println("Inside incrementRevision");
        // If the revision consists only of digits, append 'A' at the end.
    	System.out.println("revision in increment : "+revision);
        if (revision.matches("\\d+")) {
            return revision + "A";
        }
        
        // Extract the numeric part and the letter part from the revision.
        String numericPart = revision.replaceAll("[^\\d]", "");
        System.out.println("numericPart : "+numericPart);
        String letterPart = revision.replaceAll("\\d", "");
        System.out.println("letterPart : "+letterPart);
        
        // If there is a letter part, increment the letter, wrapping around to 'A' after 'Z'.
        if (!letterPart.isEmpty()) {
            char letter = letterPart.toUpperCase().charAt(0); // Convert to uppercase if it's not already.
            if (letter == 'Z') {
                // Increment the numeric part and start over with 'A' if the letter was 'Z'.
                int numericValue = Integer.parseInt(numericPart);
                return String.format("%0" + numericPart.length() + "dA", numericValue + 1);
            } else {
                // Increment the letter to the next one in the alphabet.
                return numericPart + (char)(letter + 1);
            }
        }
        
        // If none of the above conditions are met, the format is invalid.
        throw new IllegalArgumentException("Invalid revision format: " + revision);
    }


  /*  private IDfSession getAdminSession() throws DfException 
	{
		IDfSession sess = getSession();
		IDfFolder sysObj =(IDfFolder)sess.getObjectByQualification("dm_folder where object_name ='Admin' and folder('/System/Adminsess')");
		IDfClient localClient = DfClient.getLocalClient();

		String docbaseName = sess.getDocbaseName();
		IDfSessionManager m_sessionManagerRCB = null;
		IDfSession session = null;
		m_sessionManagerRCB = localClient.newSessionManager();
		IDfLoginInfo rCBloginInfo = new DfLoginInfo();
		rCBloginInfo.setUser(sysObj.getString("subject"));
		rCBloginInfo.setPassword(RegistryPasswordUtils.decrypt(sysObj.getString("log_entry")));
		m_sessionManagerRCB.setIdentity(docbaseName, rCBloginInfo);
		session = m_sessionManagerRCB.getSession(docbaseName);

		System.out.println("Admin Session created ..."+session.getLoginUserName());
		return session;

	} // GetAdminSession
*/
    
    public IDfSession getAdminSession() throws DfException{
		
		IDfSessionManager sessionMrg = null;
		IDfSession session = null;
		
		try{
			IDfLoginInfo loginInfo = new DfLoginInfo();
			loginInfo.setUser("username");
			loginInfo.setPassword("password");
			
			sessionMrg = DfClient.getLocalClient().newSessionManager();
			sessionMrg.setIdentity("repo", loginInfo);
			
			session = sessionMrg.getSession("repo");
			
			System.out.println("Admin Session created ..."+session.getLoginUserName());

			}
		catch (DfException e){
			e.printStackTrace();
		}
		/*finally{
			if(sessionMrg !=null && getAdminSession != null){
				sessionMrg.release(getAdminSession);
			}
		}*/
		return session;
	}
    public static void main(String[] args) throws Exception {
    	new NawahImportValidationForUPICRevision().validateDocNoRevision("RE-NFP-0003");
    }
}
